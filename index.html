<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VECTOR CHOPPER V8 - ULTIMATE</title>
    <style>
        /* --- CORE STYLING --- */
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        :root {
            --primary: #39ff14;   /* Game Green */
            --alert: #ff3333;     /* Crash/Bird Red */
            --dust: #ff8844;      /* Menu Dust Amber */
            --bg: #050505;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg);
            overflow: hidden;
            font-family: 'Share Tech Mono', monospace;
            /* CRITICAL: Prevents blue tap box on Android/iOS */
            -webkit-tap-highlight-color: transparent;
            /* CRITICAL: Disables browser zoom/scroll */
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle at center, #111 0%, #000 100%);
            outline: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            /* The Vector Glow */
            filter: drop-shadow(0 0 3px rgba(57, 255, 20, 0.4)) contrast(1.2) brightness(1.1);
        }

        /* --- VISUAL OVERLAYS --- */
        .scanlines {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(rgba(0,0,0,0) 50%, rgba(0,0,0,0.2) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 20;
            padding: 20px;
            box-sizing: border-box;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            color: var(--primary);
            font-size: 1.2rem;
            text-shadow: 0 0 5px var(--primary);
            letter-spacing: 2px;
        }

        /* --- MENU OVERLAY --- */
        #menu-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            /* Transparent so we can see the canvas particles behind it */
            background: rgba(0, 0, 0, 0.3); 
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            transition: opacity 0.4s ease;
        }

        h1 {
            color: var(--dust); /* Orange tint for menu title */
            font-size: 3.5rem;
            margin: 0;
            text-shadow: 0 0 15px var(--dust);
            text-align: center;
            line-height: 1.1;
        }

        p {
            color: #fff;
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 40px;
            text-align: center;
            line-height: 1.5;
            text-shadow: 0 0 5px var(--dust);
        }

        .btn {
            background: rgba(50, 20, 0, 0.6);
            border: 2px solid var(--dust);
            color: var(--dust);
            font-family: inherit;
            font-size: 1.5rem;
            padding: 20px 50px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 15px var(--dust);
            transition: transform 0.1s;
            pointer-events: auto;
            border-radius: 2px;
        }

        .btn:active {
            background: var(--dust);
            color: #000;
            transform: scale(0.95);
        }

        .hidden {
            opacity: 0;
            pointer-events: none !important;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div class="scanlines"></div>
    
    <div id="ui-layer">
        <div class="hud-row">
            <span>ALT: <span id="val-alt">0000</span></span>
            <span id="mute-indicator" style="display: none; color: var(--alert);">ðŸ”‡ MUTED</span>
            <span>DIST: <span id="val-dist">0000</span></span>
        </div>
        <div class="hud-row">
            <span style="font-size: 0.8rem">SYSTEM: <span id="val-sys">STANDBY</span></span>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="menu-overlay">
        <h1 id="menu-title">VECTOR<br>CHOPPER</h1>
        <p id="menu-desc">
            ATMOSPHERE: UNSTABLE<br>
            TAP/CLICK OR W/â†‘ TO FLY<br>
            S/â†“ TO DIVE â€¢ P/SPACE TO PAUSE<br>
            M TO MUTE â€¢ ENTER TO START
        </p>
        <button class="btn" id="btn-start">ENGAGE ROTORS</button>
    </div>
</div>

<script>
    /**
     * VECTOR CHOPPER V8
     * -----------------
     * Fixes:
     * 1. Physics: Adjusted to be very "floaty" (Low Gravity).
     * 2. Menu: Added Red/Amber twinkling dust particles.
     * 3. Audio: Added "Fade Out" logic for crashes.
     */

    // --- PHYSICS CONFIGURATION ---
    const CFG = {
        gravity: 0.08,       // Very low gravity for "floaty" feel
        thrust: 0.22,        // Balanced lift
        terminalVel: 3.5,    // Max fall speed (Prevents "falling too fast")
        speedStart: 5,
        speedInc: 0.002,
        segmentW: 30,
        bufferSize: 50       // Large buffer to prevent "straight line" lag
    };

    // --- DOM ELEMENTS ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const menu = document.getElementById('menu-overlay');
    const btnStart = document.getElementById('btn-start');
    const title = document.getElementById('menu-title');
    const desc = document.getElementById('menu-desc');
    
    const elAlt = document.getElementById('val-alt');
    const elDist = document.getElementById('val-dist');
    const elSys = document.getElementById('val-sys');
    const elMute = document.getElementById('mute-indicator');

    // --- GAME STATE ---
    let width, height;
    let state = 'MENU'; // 'MENU', 'PLAYING', 'PAUSED', 'CRASHED'
    let inputActive = false;
    let distance = 0;
    let speed = 0;
    let shake = 0;
    let canRestart = true;
    let isMuted = false;
    let lastFrameTime = 0;
    const TARGET_FPS = 60;
    const FRAME_TIME = 1000 / TARGET_FPS;
    const FRAME_TIME_TOLERANCE = 0.9; // Allow 90% of frame time to account for timing variance

    // Keyboard state for multi-key support
    const keysPressed = {
        up: false,
        down: false
    };

    // --- ENTITIES ---
    const heli = { x: 0, y: 0, dy: 0, angle: 0, r: 14 };
    let terrain = [];
    let particles = [];     // Game particles (Green smoke)
    let dustParticles = []; // Menu particles (Red/Amber)
    let birds = [];

    // --- AUDIO SYSTEM ---
    const Sfx = {
        ctx: null,
        rotorNode: null,
        rotorGain: null,
        lfo: null,
        isInit: false,

        init() {
            if (this.ctx) return;
            const AC = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AC();
            
            // 1. Generate Pink Noise (Better than white noise for engines)
            const bufferSize = this.ctx.sampleRate * 2;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            let b0=0, b1=0, b2=0, b3=0, b4=0, b5=0, b6=0;
            for(let i=0; i<bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                b0 = 0.99886 * b0 + white * 0.0555179;
                b1 = 0.99332 * b1 + white * 0.0750759;
                b2 = 0.96900 * b2 + white * 0.1538520;
                b3 = 0.86650 * b3 + white * 0.3104856;
                b4 = 0.55000 * b4 + white * 0.5329522;
                b5 = -0.7616 * b5 - white * 0.0168980;
                data[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                data[i] *= 0.11; 
                b6 = white * 0.115926;
            }

            this.rotorNode = this.ctx.createBufferSource();
            this.rotorNode.buffer = buffer;
            this.rotorNode.loop = true;

            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 600;

            this.rotorGain = this.ctx.createGain();
            this.rotorGain.gain.value = 0;

            // LFO for the "Chop" sound
            this.lfo = this.ctx.createOscillator();
            this.lfo.type = 'sine';
            this.lfo.frequency.value = 8; 

            const lfoGain = this.ctx.createGain();
            lfoGain.gain.value = 0.5;

            // Connect graph
            this.rotorNode.connect(filter);
            filter.connect(this.rotorGain);
            this.rotorGain.connect(this.ctx.destination);
            this.lfo.connect(lfoGain);
            lfoGain.connect(this.rotorGain.gain);

            this.rotorNode.start();
            this.lfo.start();
            this.isInit = true;
        },

        start() {
            if(!this.isInit) this.init();
            if(this.ctx.state === 'suspended') this.ctx.resume();
            
            // Cancel any fade outs
            this.rotorGain.gain.cancelScheduledValues(this.ctx.currentTime);
            // Ramp up only if not muted
            this.rotorGain.gain.setValueAtTime(0, this.ctx.currentTime);
            if (!isMuted) {
                this.rotorGain.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + 1.0);
            }
        },

        // Mute/Unmute toggle
        setMuted(muted) {
            isMuted = muted;
            elMute.style.display = muted ? 'inline' : 'none';
            if(!this.isInit) return;
            const now = this.ctx.currentTime;
            this.rotorGain.gain.cancelScheduledValues(now);
            if(muted) {
                this.rotorGain.gain.setValueAtTime(this.rotorGain.gain.value, now);
                this.rotorGain.gain.linearRampToValueAtTime(0, now + 0.1);
            } else if(state === 'PLAYING') {
                this.rotorGain.gain.setValueAtTime(0, now);
                this.rotorGain.gain.linearRampToValueAtTime(0.2, now + 0.3);
            }
        },

        // New Fade Out Logic - Immediately stop sound on crash
        fadeOut() {
            if(!this.isInit) return;
            const now = this.ctx.currentTime;
            const currentValue = this.rotorGain.gain.value;
            this.rotorGain.gain.cancelScheduledValues(now);
            // Ensure we have a non-zero starting value for exponential ramp
            const startValue = Math.max(currentValue, 0.01);
            this.rotorGain.gain.setValueAtTime(startValue, now);
            // Faster 0.5 second fade for game over using linear ramp for safety
            this.rotorGain.gain.linearRampToValueAtTime(0.001, now + 0.5);
            this.rotorGain.gain.linearRampToValueAtTime(0, now + 0.6);
        },

        // Complete stop - for immediate sound cutoff
        stopRotor() {
            if(!this.isInit) return;
            const now = this.ctx.currentTime;
            this.rotorGain.gain.cancelScheduledValues(now);
            this.rotorGain.gain.setValueAtTime(0, now);
        },

        throttle(on) {
            if(!this.isInit || isMuted) return;
            const t = this.ctx.currentTime;
            if(on) {
                this.lfo.frequency.setTargetAtTime(13, t, 0.2); 
                this.rotorGain.gain.setTargetAtTime(0.4, t, 0.1); 
            } else {
                this.lfo.frequency.setTargetAtTime(8, t, 0.5); 
                this.rotorGain.gain.setTargetAtTime(0.2, t, 0.5); 
            }
        },

        playExplosion() {
            if(!this.isInit || isMuted) return;
            const osc = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(120, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 0.6);
            g.gain.setValueAtTime(0.5, this.ctx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.6);
            osc.connect(g);
            g.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.7);
        },
        
        playBirdHit() {
            if(!this.isInit || isMuted) return;
            const osc = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(1500, this.ctx.currentTime);
            osc.frequency.linearRampToValueAtTime(500, this.ctx.currentTime + 0.1);
            g.gain.setValueAtTime(0.4, this.ctx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
            osc.connect(g);
            g.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.2);
        }
    };


    // --- SCREEN RESIZE ---
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        
        if(state === 'MENU') {
            heli.x = width * 0.25;
            heli.y = height * 0.5;
            initDust(); // Reset dust on resize
        }
    }
    window.addEventListener('resize', resize);


    // --- MENU DUST (ATMOSPHERE) ---
    function initDust() {
        dustParticles = [];
        const count = Math.min((width * height) / 2000, 100);
        for(let i=0; i<count; i++) {
            dustParticles.push({
                x: Math.random() * width,
                y: Math.random() * height,
                vx: (Math.random() - 0.5) * 0.3, // Very slow
                vy: (Math.random() - 0.5) * 0.3,
                size: Math.random() * 2 + 0.5,
                phase: Math.random() * Math.PI * 2,
                speed: Math.random() * 0.05 + 0.01
            });
        }
    }

    function drawDust() {
        dustParticles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            
            // Wrap around screen
            if(p.x < 0) p.x = width;
            if(p.x > width) p.x = 0;
            if(p.y < 0) p.y = height;
            if(p.y > height) p.y = 0;

            // Twinkle effect (Sine wave alpha)
            p.phase += p.speed;
            const alpha = 0.3 + Math.sin(p.phase) * 0.3; // 0.0 to 0.6 opacity

            ctx.fillStyle = `rgba(255, 100, 50, ${alpha})`; // Red/Amber color
            ctx.shadowBlur = p.size * 2;
            ctx.shadowColor = '#ff5533';
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
            ctx.fill();
        });
        ctx.shadowBlur = 0; // Reset shadow
    }

    // Track if mouse/touch is currently active
    let pointerDown = false;
    function isPointerActive() {
        return pointerDown;
    }

    // --- INPUT HANDLER (Combined pointer and keyboard support) ---
    // Unified function to update inputActive state based on all input sources
    function updateInputState() {
        if(state !== 'PLAYING') return;
        
        const shouldBeActive = pointerDown || keysPressed.up;
        
        if(shouldBeActive && !inputActive) {
            inputActive = true;
            Sfx.throttle(true);
        } else if(!shouldBeActive && inputActive) {
            inputActive = false;
            Sfx.throttle(false);
        }
    }

    // Pointer (mouse/touch) handlers
    function pointerStart(e) {
        if(e.type === 'touchstart') {
            e.preventDefault();
        }
        if(e.target.tagName === 'BUTTON') return;
        if(state !== 'PLAYING') return;
        pointerDown = true;
        updateInputState();
    }
    function pointerEnd(e) {
        pointerDown = false;
        if(state !== 'PLAYING') return;
        updateInputState();
    }

    // Prevent touch events from triggering default browser actions during gameplay
    document.getElementById('game-container').addEventListener('touchstart', (e) => {
        if(state === 'PLAYING') {
            e.preventDefault();
        }
    }, {passive: false});
    
    window.addEventListener('mousedown', pointerStart);
    window.addEventListener('touchstart', pointerStart, {passive: false});
    window.addEventListener('mouseup', pointerEnd);
    window.addEventListener('touchend', pointerEnd);

    // --- KEYBOARD CONTROLS ---
    function handleKeyDown(e) {
        const key = e.key.toLowerCase();
        
        // Start game with Enter from menu
        if((key === 'enter') && state === 'MENU' && canRestart) {
            e.preventDefault();
            resetGame();
            return;
        }

        // Pause/Resume with P or Space
        if(key === 'p' || key === ' ') {
            e.preventDefault();
            if(state === 'PLAYING') {
                pauseGame();
            } else if(state === 'PAUSED') {
                resumeGame();
            } else if(state === 'MENU' && key === ' ') {
                // Space can also start from menu
                if(canRestart) resetGame();
            }
            return;
        }

        // Mute with M
        if(key === 'm') {
            e.preventDefault();
            Sfx.setMuted(!isMuted);
            return;
        }

        // Up controls: W, ArrowUp
        if(key === 'w' || key === 'arrowup') {
            e.preventDefault();
            if(state === 'PLAYING') {
                keysPressed.up = true;
                updateInputState();
            }
            return;
        }

        // Down controls: S, ArrowDown
        if(key === 's' || key === 'arrowdown') {
            e.preventDefault();
            if(state === 'PLAYING') {
                keysPressed.down = true;
            }
            return;
        }
    }

    function handleKeyUp(e) {
        const key = e.key.toLowerCase();

        if(key === 'w' || key === 'arrowup') {
            keysPressed.up = false;
            updateInputState();
            return;
        }

        if(key === 's' || key === 'arrowdown') {
            keysPressed.down = false;
            return;
        }
    }

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    // --- PAUSE FUNCTIONS ---
    function pauseGame() {
        if(state !== 'PLAYING') return;
        state = 'PAUSED';
        inputActive = false;
        Sfx.throttle(false);
        
        // Show pause menu
        title.innerText = "PAUSED";
        title.style.color = "var(--dust)";
        desc.innerHTML = "PRESS P OR SPACE TO RESUME<br>M TO TOGGLE SOUND";
        btnStart.innerText = "RESUME";
        menu.classList.remove('hidden');
        
        elSys.innerText = "PAUSED";
    }

    function resumeGame() {
        if(state !== 'PAUSED') return;
        state = 'PLAYING';
        menu.classList.add('hidden');
        elSys.innerText = "ONLINE";
        elSys.style.color = "var(--primary)";
    }


    // --- GAME LOGIC ---

    function resetGame() {
        if(!canRestart) return;

        heli.y = height / 2;
        heli.dy = 0; 
        heli.angle = 0;
        heli.x = width * 0.25;
        
        distance = 0;
        speed = CFG.speedStart;
        state = 'PLAYING';
        shake = 0;
        particles = [];
        terrain = [];
        birds = [];
        
        // Reset input states
        inputActive = false;
        pointerDown = false;
        keysPressed.up = false;
        keysPressed.down = false;

        elSys.innerText = "ONLINE";
        elSys.style.color = "var(--primary)";
        menu.classList.add('hidden');

        // Generate Terrain Buffer
        let tY = 50, bY = 50;
        const total = Math.ceil(width/CFG.segmentW) + CFG.bufferSize;
        
        for(let i=0; i<total; i++) {
            if(i > 15) { 
                tY += (Math.random()*20 - 10);
                bY += (Math.random()*20 - 10);
                if(tY < 20) tY = 20; if(tY > height/3) tY = height/3;
                if(bY < 20) bY = 20; if(bY > height/3) bY = height/3;
            }
            terrain.push({t: tY, b: bY});
        }

        Sfx.start();
    }

    function spawnBird() {
        const y = Math.random() * (height - 200) + 100;
        birds.push({
            x: width + 50,
            y: y,
            w: 15, h: 10,
            vx: -(speed + 3 + Math.random()*2),
            flap: Math.random() * 10
        });
    }

    function update() {
        distance += speed;
        speed += CFG.speedInc;

        // 1. Physics (Revised Floaty Logic with keyboard support)
        if(inputActive) {
            heli.dy -= CFG.thrust; // Lift
            heli.angle = -0.25;
            
            // Green Smoke
            if(Math.random() > 0.5) {
                particles.push({
                    x: heli.x - 15, y: heli.y + 5,
                    vx: -speed - 2, vy: (Math.random()-0.5)*2,
                    life: 1, color: '#39ff14'
                });
            }
        } else if(keysPressed.down) {
            // Accelerate downward when holding down/S
            heli.dy += CFG.gravity * 2.5; // Fall faster
            heli.angle = 0.3;
        } else {
            heli.dy += CFG.gravity; // Normal Gravity
            heli.angle = 0.15;
        }

        // Speed Cap (Terminal Velocity)
        if(heli.dy > CFG.terminalVel) heli.dy = CFG.terminalVel;
        if(heli.dy < -CFG.terminalVel) heli.dy = -CFG.terminalVel;
        
        heli.y += heli.dy;

        // 2. Terrain Generation
        if(terrain.length < (width/CFG.segmentW) + CFG.bufferSize) {
            const last = terrain[terrain.length-1];
            let nT = last.t + (Math.random()*30 - 15);
            let nB = last.b + (Math.random()*30 - 15);
            if(nT < 20) nT = 20;
            if(nB < 20) nB = 20;
            if(height - nT - nB < 200) { nT -= 10; nB -= 10; }
            terrain.push({t: nT, b: nB});
        }
        if(distance % CFG.segmentW < speed) terrain.shift();

        // 3. Birds
        if(Math.random() < 0.005 + (speed * 0.0005)) spawnBird();
        birds.forEach(b => {
            b.x += b.vx;
            b.flap += 0.3;
            // Collision
            if(Math.abs(heli.x - b.x) < 20 && Math.abs(heli.y - b.y) < 15) {
                gameOver(true);
            }
        });
        birds = birds.filter(b => b.x > -50);

        // 4. Terrain Collision
        const hIdx = Math.floor(heli.x / CFG.segmentW);
        // Check 2 segments
        for(let i=0; i<2; i++) {
            if(terrain[hIdx]) {
                const ceil = terrain[hIdx].t;
                const floor = height - terrain[hIdx].b;
                if(heli.y - heli.r < ceil || heli.y + heli.r > floor) gameOver(false);
            }
        }
        if(heli.y < 0 || heli.y > height) gameOver(false);

        // 5. Particles Update
        particles.forEach(p => {
            p.x += p.vx; p.y += p.vy; p.life -= 0.05;
        });
        particles = particles.filter(p => p.life > 0);

        elAlt.innerText = Math.floor(height - heli.y);
        elDist.innerText = Math.floor(distance/10);
    }

    function gameOver(isBird) {
        state = 'CRASHED';
        shake = 20;
        inputActive = false;
        pointerDown = false;
        keysPressed.up = false;
        keysPressed.down = false;

        // Immediately fade out rotor sound
        Sfx.fadeOut();
        Sfx.playExplosion();
        if(isBird) Sfx.playBirdHit();

        elSys.innerText = isBird ? "BIRD STRIKE" : "IMPACT";
        elSys.style.color = "var(--alert)";

        setTimeout(() => {
            // Ensure sound is completely stopped after crash animation
            Sfx.stopRotor();
            
            title.innerText = "MISSION FAILED";
            title.style.color = "var(--alert)";
            desc.innerHTML = `DISTANCE: ${Math.floor(distance/10)}<br>CAUSE: ${isBird ? "BIOLOGICAL ENTITY" : "TERRAIN IMPACT"}<br><br>PRESS ENTER OR CLICK TO RESTART`;
            btnStart.innerText = "REBOOT SYSTEM";
            menu.classList.remove('hidden');
            
            canRestart = false;
            setTimeout(() => { canRestart = true; }, 500);
            
            // Switch back to menu mode logic after crash
            state = 'MENU';
            initDust();
        }, 500);
    }

    function draw() {
        // Clear screen
        ctx.fillStyle = '#050505';
        ctx.fillRect(0, 0, width, height);

        // --- MENU/PAUSED MODE DRAWING ---
        if(state === 'MENU' || state === 'PAUSED') {
            drawDust();
            if(state === 'PAUSED') {
                // Still draw the game world faded in background when paused
                ctx.globalAlpha = 0.3;
                drawGameWorld();
                ctx.globalAlpha = 1;
            }
            return;
        }

        // --- GAME MODE DRAWING ---
        drawGameWorld();
    }

    function drawGameWorld() {
        ctx.save();
        if(shake > 0) {
            ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
            shake *= 0.9;
        }

        // Terrain
        ctx.strokeStyle = '#39ff14';
        ctx.lineWidth = 2;
        ctx.beginPath();
        let off = -(distance % CFG.segmentW);
        ctx.moveTo(off, terrain[0]?.t || 0);
        terrain.forEach((t, i) => ctx.lineTo(off + i*CFG.segmentW, t.t));
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(off, height - (terrain[0]?.b || 0));
        terrain.forEach((t, i) => ctx.lineTo(off + i*CFG.segmentW, height - t.b));
        ctx.stroke();

        // Birds
        ctx.strokeStyle = '#ffaa55';
        birds.forEach(b => {
            ctx.beginPath();
            let wy = Math.sin(b.flap) * 8;
            ctx.moveTo(b.x, b.y);
            ctx.lineTo(b.x + b.w/2, b.y + wy);
            ctx.lineTo(b.x + b.w, b.y);
            ctx.stroke();
        });
        
        // Particles
        particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life;
            ctx.fillRect(p.x, p.y, 3, 3);
        });
        ctx.globalAlpha = 1;

        // Helicopter
        ctx.translate(heli.x, heli.y);
        ctx.rotate(heli.angle);
        ctx.strokeStyle = '#39ff14';
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#39ff14';
        
        ctx.beginPath();
        ctx.arc(0,0, heli.r, 0, Math.PI*2);
        ctx.moveTo(-10,0); ctx.lineTo(-30,0);
        ctx.moveTo(-30,-5); ctx.lineTo(-30,5);
        ctx.stroke();

        ctx.beginPath();
        let b = 35 * Math.sin(Date.now()/20);
        ctx.moveTo(-b, -12); ctx.lineTo(b, -12);
        ctx.moveTo(0, -12); ctx.lineTo(0, -10);
        ctx.stroke();

        // Flame
        if(inputActive) {
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(-4, 10);
            ctx.lineTo(4, 10);
            ctx.lineTo(0, 20 + Math.random()*10);
            ctx.fill();
        }

        ctx.restore();
    }

    // --- MAIN LOOP (Optimized for 60 FPS) ---
    function loop(currentTime) {
        // Calculate delta time for smooth animation
        if (!lastFrameTime) lastFrameTime = currentTime;
        const deltaTime = currentTime - lastFrameTime;
        
        // Only update if enough time has passed (for consistent 60 FPS)
        if (deltaTime >= FRAME_TIME * FRAME_TIME_TOLERANCE) {
            lastFrameTime = currentTime;
            
            if(state === 'PLAYING') update();
            draw();
        }
        
        requestAnimationFrame(loop);
    }

    // Init
    resize();
    initDust();
    loop();

    btnStart.addEventListener('click', () => {
        if(state === 'PAUSED') {
            resumeGame();
        } else {
            resetGame();
        }
    });

</script>
</body>
</html>

  
