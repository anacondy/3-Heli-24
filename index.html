<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#050505">
    <title>VECTOR CHOPPER 3D</title>
    <style>
        /* --- CORE STYLING (Mobile Optimized for 16:9 and 20:9) --- */
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        :root {
            --primary: #39ff14;
            --alert: #ff3333;
            --dust: #ff8844;
            --bg: #050505;
            /* Safe area insets for notched devices */
            --sai-top: env(safe-area-inset-top, 0px);
            --sai-bottom: env(safe-area-inset-bottom, 0px);
            --sai-left: env(safe-area-inset-left, 0px);
            --sai-right: env(safe-area-inset-right, 0px);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            width: 100%;
            height: 100%;
            background-color: var(--bg);
            overflow: hidden;
            font-family: 'Share Tech Mono', monospace, 'Courier New', monospace;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            position: fixed;
            top: 0;
            left: 0;
        }

        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #111 0%, #000 100%);
            outline: none;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* 3D-like glow effect */
            filter: drop-shadow(0 0 2px rgba(57, 255, 20, 0.3));
        }

        /* --- SCANLINES --- */
        .scanlines {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(rgba(0,0,0,0) 50%, rgba(0,0,0,0.12) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        /* --- UI LAYER (Mobile responsive) --- */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 20;
            padding: calc(10px + var(--sai-top)) calc(10px + var(--sai-right)) calc(10px + var(--sai-bottom)) calc(10px + var(--sai-left));
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--primary);
            font-size: clamp(0.65rem, 2.5vw, 1.1rem);
            text-shadow: 0 0 5px var(--primary);
            letter-spacing: 1px;
        }

        /* --- MENU OVERLAY (Mobile responsive) --- */
        #menu-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.4);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: calc(15px + var(--sai-top)) calc(15px + var(--sai-right)) calc(15px + var(--sai-bottom)) calc(15px + var(--sai-left));
            pointer-events: auto;
            transition: opacity 0.3s ease;
        }

        h1 {
            color: var(--dust);
            font-size: clamp(1.6rem, 7vw, 3.2rem);
            margin: 0 0 8px 0;
            text-shadow: 0 0 12px var(--dust);
            text-align: center;
            line-height: 1.1;
        }

        .version-tag {
            color: var(--primary);
            font-size: clamp(0.55rem, 1.8vw, 0.75rem);
            opacity: 0.7;
            margin-bottom: 12px;
        }

        p {
            color: #fff;
            font-size: clamp(0.65rem, 2.2vw, 0.95rem);
            opacity: 0.9;
            margin-bottom: 20px;
            text-align: center;
            line-height: 1.5;
            text-shadow: 0 0 4px var(--dust);
            max-width: 90%;
        }

        .btn {
            background: rgba(50, 20, 0, 0.7);
            border: 2px solid var(--dust);
            color: var(--dust);
            font-family: inherit;
            font-size: clamp(0.9rem, 3.5vw, 1.4rem);
            padding: clamp(10px, 2.5vw, 18px) clamp(20px, 7vw, 45px);
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 12px var(--dust);
            transition: transform 0.1s, background 0.1s;
            pointer-events: auto;
            border-radius: 4px;
            min-height: 44px;
        }

        .btn:active {
            background: var(--dust);
            color: #000;
            transform: scale(0.95);
        }

        .hidden {
            opacity: 0;
            pointer-events: none !important;
        }

        /* --- MOBILE TOUCH ZONE --- */
        #touch-zone {
            position: absolute;
            bottom: calc(15px + var(--sai-bottom));
            right: calc(15px + var(--sai-right));
            width: clamp(55px, 14vw, 90px);
            height: clamp(55px, 14vw, 90px);
            background: rgba(57, 255, 20, 0.12);
            border: 2px solid rgba(57, 255, 20, 0.35);
            border-radius: 50%;
            z-index: 50;
            pointer-events: auto;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: clamp(0.55rem, 1.8vw, 0.75rem);
            color: var(--primary);
            text-align: center;
            opacity: 0.75;
        }

        #touch-zone.active {
            background: rgba(57, 255, 20, 0.35);
            transform: scale(0.95);
        }

        /* --- MUTE FEEDBACK --- */
        #mute-feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(1.3rem, 4.5vw, 2.2rem);
            font-weight: bold;
            pointer-events: none;
            opacity: 0;
            z-index: 150;
            text-shadow: 0 0 15px currentColor;
            letter-spacing: 2px;
        }

        @keyframes muteFeedback {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            15% { opacity: 1; transform: translate(-50%, -50%) scale(1.15); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
        }

        @keyframes unmuteFeedback {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.0); }
        }

        .mute-feedback-muted {
            color: var(--alert);
            animation: muteFeedback 1.3s ease-out forwards;
        }

        .mute-feedback-unmuted {
            color: var(--primary);
            animation: unmuteFeedback 0.9s ease-out forwards;
        }

        /* --- MOBILE HINT --- */
        .mobile-hint {
            display: none;
            position: absolute;
            bottom: calc(90px + var(--sai-bottom));
            left: 50%;
            transform: translateX(-50%);
            color: var(--primary);
            font-size: clamp(0.55rem, 1.8vw, 0.75rem);
            opacity: 0.5;
            text-align: center;
            z-index: 60;
            pointer-events: none;
        }

        /* Show mobile elements on touch devices */
        @media (hover: none) and (pointer: coarse) {
            #touch-zone { display: flex; }
            .mobile-hint { display: block; }
        }

        /* Landscape mobile optimization */
        @media screen and (max-height: 450px) and (orientation: landscape) {
            h1 {
                font-size: clamp(1rem, 4.5vh, 1.8rem);
                margin-bottom: 4px;
            }
            p {
                font-size: clamp(0.55rem, 1.8vh, 0.75rem);
                margin-bottom: 8px;
                line-height: 1.3;
            }
            .btn {
                padding: 8px 25px;
                font-size: clamp(0.75rem, 2.8vh, 0.95rem);
            }
            .version-tag { margin-bottom: 4px; }
        }

        /* Extra tall phones (20:9, 21:9) */
        @media screen and (min-aspect-ratio: 2/1) {
            #ui-layer {
                padding-left: calc(20px + var(--sai-left));
                padding-right: calc(20px + var(--sai-right));
            }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>
    
    <div id="ui-layer">
        <div class="hud-row">
            <span>ALT: <span id="val-alt">0000</span></span>
            <span id="mute-indicator" style="display: none; color: var(--alert);">ðŸ”‡</span>
            <span>DIST: <span id="val-dist">0000</span></span>
        </div>
        <div class="hud-row">
            <span>FPS: <span id="val-fps">60</span></span>
            <span style="font-size: clamp(0.55rem, 1.8vw, 0.75rem)">STATUS: <span id="val-sys">STANDBY</span></span>
        </div>
    </div>

    <div id="touch-zone">TAP<br>FLY</div>
    <div class="mobile-hint">TAP ANYWHERE TO FLY</div>

    <div id="menu-overlay">
        <h1 id="menu-title">VECTOR<br>CHOPPER</h1>
        <div class="version-tag">3D v2.0</div>
        <p id="menu-desc">
            TAP/CLICK TO FLY UP<br>
            W/â†‘/SPACE: ASCEND â€¢ S/â†“: DIVE<br>
            P/ENTER: PAUSE â€¢ M: MUTE
        </p>
        <button class="btn" id="btn-start">ENGAGE ROTORS</button>
    </div>

    <div id="mute-feedback"></div>
</div>

<script>
/**
 * VECTOR CHOPPER 3D v2.0
 * ----------------------
 * Features:
 * 1. Mobile-optimized for 16:9 and 20:9 devices
 * 2. Consistent 60 FPS with delta-time physics
 * 3. Robust audio handling - sound stops on crash
 * 4. 3D-style graphics with perspective and depth
 * 5. Touch-friendly controls
 */

(function() {
    'use strict';

    // ===== CONFIGURATION =====
    const CONFIG = {
        // Physics (delta-time based, values per second)
        gravity: 380,
        thrust: 580,
        terminalVel: 280,
        maxRiseVel: 240,
        speedStart: 180,
        speedInc: 0.8,
        
        // Terrain
        segmentWidth: 35,
        terrainBuffer: 55,
        minGap: 160,
        
        // Performance
        targetFPS: 60,
        maxDeltaTime: 0.05
    };

    // ===== DOM ELEMENTS =====
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('game-container');
    const menu = document.getElementById('menu-overlay');
    const btnStart = document.getElementById('btn-start');
    const title = document.getElementById('menu-title');
    const desc = document.getElementById('menu-desc');
    const touchZone = document.getElementById('touch-zone');
    
    const elAlt = document.getElementById('val-alt');
    const elDist = document.getElementById('val-dist');
    const elSys = document.getElementById('val-sys');
    const elFps = document.getElementById('val-fps');
    const elMute = document.getElementById('mute-indicator');
    const elMuteFeedback = document.getElementById('mute-feedback');

    // ===== GAME STATE =====
    let width = window.innerWidth;
    let height = window.innerHeight;
    let state = 'MENU';
    let inputActive = false;
    let distance = 0;
    let scrollSpeed = 0;
    let canRestart = true;
    let isMuted = false;
    
    // FPS tracking
    let frameCount = 0;
    let lastFpsUpdate = 0;
    let currentFps = 60;
    let lastFrameTime = 0;

    // Input tracking
    let pointerDown = false;
    const keysPressed = { up: false, down: false };

    // ===== ENTITIES =====
    const helicopter = {
        x: 0, y: 0,
        velocityY: 0,
        angle: 0,
        radius: 14,
        rotorAngle: 0
    };

    let terrain = [];
    let particles = [];
    let dustParticles = [];
    let birds = [];
    let stars = [];
    let shake = { x: 0, y: 0, intensity: 0 };

    // ===== AUDIO SYSTEM (Robust with crash handling) =====
    const Audio = {
        ctx: null,
        rotorNode: null,
        rotorGain: null,
        masterGain: null,
        lfo: null,
        isRunning: false,
        isInitialized: false,

        init() {
            if (this.ctx) return;
            
            try {
                const AC = window.AudioContext || window.webkitAudioContext;
                if (!AC) return;
                
                this.ctx = new AC();
                
                // Master gain for global muting
                this.masterGain = this.ctx.createGain();
                this.masterGain.connect(this.ctx.destination);
                this.masterGain.gain.value = isMuted ? 0 : 1;
                
                // Pink noise for rotor sound
                const bufferSize = this.ctx.sampleRate * 2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                let b0=0, b1=0, b2=0, b3=0, b4=0, b5=0, b6=0;
                
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    b0 = 0.99886 * b0 + white * 0.0555179;
                    b1 = 0.99332 * b1 + white * 0.0750759;
                    b2 = 0.96900 * b2 + white * 0.1538520;
                    b3 = 0.86650 * b3 + white * 0.3104856;
                    b4 = 0.55000 * b4 + white * 0.5329522;
                    b5 = -0.7616 * b5 - white * 0.0168980;
                    data[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
                    b6 = white * 0.115926;
                }

                this.rotorNode = this.ctx.createBufferSource();
                this.rotorNode.buffer = buffer;
                this.rotorNode.loop = true;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 600;

                this.rotorGain = this.ctx.createGain();
                this.rotorGain.gain.value = 0;

                // LFO for chopping sound
                this.lfo = this.ctx.createOscillator();
                this.lfo.type = 'sine';
                this.lfo.frequency.value = 8;

                const lfoGain = this.ctx.createGain();
                lfoGain.gain.value = 0.5;

                // Connect audio graph
                this.rotorNode.connect(filter);
                filter.connect(this.rotorGain);
                this.rotorGain.connect(this.masterGain);
                this.lfo.connect(lfoGain);
                lfoGain.connect(this.rotorGain.gain);

                this.rotorNode.start();
                this.lfo.start();
                this.isInitialized = true;
            } catch (e) {
                console.warn('Audio initialization failed:', e);
            }
        },

        start() {
            if (!this.isInitialized) this.init();
            if (!this.ctx) return;
            
            if (this.ctx.state === 'suspended') {
                this.ctx.resume();
            }
            
            this.isRunning = true;
            const now = this.ctx.currentTime;
            this.rotorGain.gain.cancelScheduledValues(now);
            this.rotorGain.gain.setValueAtTime(0, now);
            
            if (!isMuted) {
                this.rotorGain.gain.linearRampToValueAtTime(0.18, now + 0.4);
            }
        },

        // CRITICAL: Complete stop - called on crash
        stop() {
            if (!this.isInitialized || !this.ctx) return;
            
            this.isRunning = false;
            const now = this.ctx.currentTime;
            
            // Immediate stop - no delay
            this.rotorGain.gain.cancelScheduledValues(now);
            this.rotorGain.gain.setValueAtTime(0, now);
        },

        // Quick fade out for crash
        fadeOut() {
            if (!this.isInitialized || !this.ctx) return;
            
            this.isRunning = false;
            const now = this.ctx.currentTime;
            const currentVal = this.rotorGain.gain.value;
            
            this.rotorGain.gain.cancelScheduledValues(now);
            this.rotorGain.gain.setValueAtTime(currentVal, now);
            this.rotorGain.gain.linearRampToValueAtTime(0, now + 0.25);
        },

        setMuted(muted) {
            isMuted = muted;
            elMute.style.display = muted ? 'inline' : 'none';
            
            // Visual feedback
            elMuteFeedback.textContent = muted ? 'ðŸ”‡ MUTED' : 'ðŸ”Š UNMUTED';
            elMuteFeedback.className = muted ? 'mute-feedback-muted' : 'mute-feedback-unmuted';
            void elMuteFeedback.offsetWidth;
            elMuteFeedback.className = muted ? 'mute-feedback-muted' : 'mute-feedback-unmuted';
            
            if (!this.isInitialized || !this.ctx) return;
            
            if (muted) {
                this.masterGain.gain.setValueAtTime(0, this.ctx.currentTime);
            } else {
                this.masterGain.gain.setValueAtTime(1, this.ctx.currentTime);
            }
        },

        throttle(on) {
            if (!this.isInitialized || !this.ctx || isMuted || !this.isRunning) return;
            
            const t = this.ctx.currentTime;
            if (on) {
                this.lfo.frequency.setTargetAtTime(13, t, 0.15);
                this.rotorGain.gain.setTargetAtTime(0.32, t, 0.08);
            } else {
                this.lfo.frequency.setTargetAtTime(8, t, 0.35);
                this.rotorGain.gain.setTargetAtTime(0.18, t, 0.25);
            }
        },

        playExplosion() {
            if (!this.isInitialized || !this.ctx || isMuted) return;
            
            try {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 0.4);
                gain.gain.setValueAtTime(0.35, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.5);
            } catch (e) {}
        },

        playBirdHit() {
            if (!this.isInitialized || !this.ctx || isMuted) return;
            
            try {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(1400, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(350, this.ctx.currentTime + 0.12);
                gain.gain.setValueAtTime(0.25, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.18);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            } catch (e) {}
        }
    };

    // ===== SCREEN RESIZE =====
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        
        if (state === 'MENU') {
            helicopter.x = width * 0.25;
            helicopter.y = height * 0.5;
            initDust();
            initStars();
        }
    }
    
    window.addEventListener('resize', resize);
    window.addEventListener('orientationchange', () => setTimeout(resize, 100));

    // ===== BACKGROUND STARS (3D effect) =====
    function initStars() {
        stars = [];
        const count = Math.min(Math.floor((width * height) / 4000), 120);
        
        for (let i = 0; i < count; i++) {
            stars.push({
                x: Math.random() * width,
                y: Math.random() * height,
                z: Math.random() * 3 + 0.5, // Depth for parallax
                size: Math.random() * 2 + 0.5,
                brightness: Math.random() * 0.5 + 0.3
            });
        }
    }

    function updateStars(dt) {
        const scrollAmount = scrollSpeed * dt;
        stars.forEach(s => {
            // Parallax effect - further stars move slower
            s.x -= scrollAmount / s.z;
            if (s.x < 0) {
                s.x = width + 10;
                s.y = Math.random() * height;
            }
        });
    }

    function drawStars() {
        stars.forEach(s => {
            const alpha = s.brightness * (0.7 + Math.sin(Date.now() / 500 + s.x) * 0.3);
            ctx.fillStyle = `rgba(57, 255, 20, ${alpha})`;
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.size / s.z, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    // ===== MENU DUST PARTICLES =====
    function initDust() {
        dustParticles = [];
        const count = Math.min(Math.floor((width * height) / 3500), 70);
        
        for (let i = 0; i < count; i++) {
            dustParticles.push({
                x: Math.random() * width,
                y: Math.random() * height,
                vx: (Math.random() - 0.5) * 0.4,
                vy: (Math.random() - 0.5) * 0.4,
                size: Math.random() * 2.5 + 1,
                phase: Math.random() * Math.PI * 2,
                speed: Math.random() * 0.025 + 0.008
            });
        }
    }

    function updateDust(dt) {
        dustParticles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.phase += p.speed;
            
            if (p.x < 0) p.x = width;
            if (p.x > width) p.x = 0;
            if (p.y < 0) p.y = height;
            if (p.y > height) p.y = 0;
        });
    }

    function drawDust() {
        dustParticles.forEach(p => {
            const alpha = 0.25 + Math.sin(p.phase) * 0.25;
            ctx.fillStyle = `rgba(255, 100, 50, ${alpha})`;
            ctx.shadowBlur = p.size * 1.5;
            ctx.shadowColor = '#ff5533';
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.shadowBlur = 0;
    }

    // ===== INPUT HANDLING =====
    function updateInputState() {
        if (state !== 'PLAYING') return;
        
        const shouldBeActive = pointerDown || keysPressed.up;
        
        if (shouldBeActive !== inputActive) {
            inputActive = shouldBeActive;
            Audio.throttle(inputActive);
            
            if (inputActive) {
                touchZone.classList.add('active');
            } else {
                touchZone.classList.remove('active');
            }
        }
    }

    function handlePointerDown(e) {
        if (e.type === 'touchstart') e.preventDefault();
        if (e.target.tagName === 'BUTTON') return;
        if (state !== 'PLAYING') return;
        
        pointerDown = true;
        updateInputState();
    }

    function handlePointerUp() {
        pointerDown = false;
        if (state !== 'PLAYING') return;
        updateInputState();
    }

    function handleKeyDown(e) {
        const key = e.key.toLowerCase();
        
        if (key === 'enter') {
            e.preventDefault();
            if (state === 'MENU' && canRestart) resetGame();
            else if (state === 'PLAYING') pauseGame();
            else if (state === 'PAUSED') resumeGame();
            return;
        }

        if (key === 'p') {
            e.preventDefault();
            if (state === 'PLAYING') pauseGame();
            else if (state === 'PAUSED') resumeGame();
            return;
        }

        if (key === 'm') {
            e.preventDefault();
            Audio.setMuted(!isMuted);
            return;
        }

        if (key === 'w' || key === 'arrowup' || key === ' ') {
            e.preventDefault();
            if (state === 'PLAYING') {
                keysPressed.up = true;
                updateInputState();
            } else if (state === 'MENU' && key === ' ' && canRestart) {
                resetGame();
            }
            return;
        }

        if (key === 's' || key === 'arrowdown') {
            e.preventDefault();
            if (state === 'PLAYING') {
                keysPressed.down = true;
            }
            return;
        }
    }

    function handleKeyUp(e) {
        const key = e.key.toLowerCase();

        if (key === 'w' || key === 'arrowup' || key === ' ') {
            keysPressed.up = false;
            updateInputState();
            return;
        }

        if (key === 's' || key === 'arrowdown') {
            keysPressed.down = false;
            return;
        }
    }

    // Event listeners
    container.addEventListener('touchstart', handlePointerDown, { passive: false });
    window.addEventListener('touchend', handlePointerUp);
    window.addEventListener('mousedown', handlePointerDown);
    window.addEventListener('mouseup', handlePointerUp);
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    // ===== GAME FUNCTIONS =====
    function pauseGame() {
        if (state !== 'PLAYING') return;
        state = 'PAUSED';
        inputActive = false;
        Audio.throttle(false);
        
        title.innerText = "PAUSED";
        title.style.color = "var(--dust)";
        desc.innerHTML = "PRESS P OR ENTER TO RESUME<br>M TO TOGGLE SOUND";
        btnStart.innerText = "RESUME";
        menu.classList.remove('hidden');
        elSys.innerText = "PAUSED";
    }

    function resumeGame() {
        if (state !== 'PAUSED') return;
        state = 'PLAYING';
        menu.classList.add('hidden');
        elSys.innerText = "ONLINE";
        elSys.style.color = "var(--primary)";
        lastFrameTime = performance.now();
    }

    function resetGame() {
        if (!canRestart) return;

        helicopter.y = height / 2;
        helicopter.velocityY = 0;
        helicopter.angle = 0;
        helicopter.x = width * 0.25;
        helicopter.rotorAngle = 0;
        
        distance = 0;
        scrollSpeed = CONFIG.speedStart;
        state = 'PLAYING';
        shake.intensity = 0;
        particles = [];
        birds = [];
        
        // Generate terrain
        terrain = [];
        let topHeight = 55;
        let bottomHeight = 55;
        const totalSegments = Math.ceil(width / CONFIG.segmentWidth) + CONFIG.terrainBuffer;
        
        for (let i = 0; i < totalSegments; i++) {
            if (i > 10) {
                topHeight += (Math.random() * 18 - 9);
                bottomHeight += (Math.random() * 18 - 9);
                
                topHeight = Math.max(25, Math.min(height / 3, topHeight));
                bottomHeight = Math.max(25, Math.min(height / 3, bottomHeight));
                
                if (height - topHeight - bottomHeight < CONFIG.minGap) {
                    topHeight -= 12;
                    bottomHeight -= 12;
                }
            }
            terrain.push({ top: topHeight, bottom: bottomHeight });
        }
        
        initStars();
        
        // Reset inputs
        inputActive = false;
        pointerDown = false;
        keysPressed.up = false;
        keysPressed.down = false;
        touchZone.classList.remove('active');

        elSys.innerText = "ONLINE";
        elSys.style.color = "var(--primary)";
        menu.classList.add('hidden');

        Audio.start();
        lastFrameTime = performance.now();
    }

    function spawnBird() {
        const y = Math.random() * (height - 180) + 90;
        birds.push({
            x: width + 40,
            y: y,
            vx: -(scrollSpeed + 80 + Math.random() * 60),
            flap: Math.random() * 10,
            flapSpeed: 0.12 + Math.random() * 0.08
        });
    }

    function update(dt) {
        // Cap delta time
        dt = Math.min(dt, CONFIG.maxDeltaTime);
        
        distance += scrollSpeed * dt;
        scrollSpeed += CONFIG.speedInc * dt;

        // Physics
        if (inputActive) {
            helicopter.velocityY -= CONFIG.thrust * dt;
            helicopter.angle = -0.22;
            
            // Spawn particles
            if (Math.random() > 0.4) {
                particles.push({
                    x: helicopter.x - 18,
                    y: helicopter.y + 4,
                    vx: -scrollSpeed - 80,
                    vy: (Math.random() - 0.5) * 70,
                    life: 1
                });
            }
        } else if (keysPressed.down) {
            helicopter.velocityY += CONFIG.gravity * 1.8 * dt;
            helicopter.angle = 0.28;
        } else {
            helicopter.velocityY += CONFIG.gravity * dt;
            helicopter.angle = 0.12;
        }

        // Velocity limits
        helicopter.velocityY = Math.max(-CONFIG.maxRiseVel, Math.min(CONFIG.terminalVel, helicopter.velocityY));
        helicopter.y += helicopter.velocityY * dt;
        
        // Rotor animation
        helicopter.rotorAngle += dt * 25;

        // Update stars (parallax)
        updateStars(dt);

        // Terrain generation
        while (terrain.length < Math.ceil(width / CONFIG.segmentWidth) + CONFIG.terrainBuffer) {
            const last = terrain[terrain.length - 1];
            let newTop = last.top + (Math.random() * 22 - 11);
            let newBottom = last.bottom + (Math.random() * 22 - 11);
            
            newTop = Math.max(25, Math.min(height / 3, newTop));
            newBottom = Math.max(25, Math.min(height / 3, newBottom));
            
            if (height - newTop - newBottom < CONFIG.minGap) {
                newTop -= 10;
                newBottom -= 10;
            }
            
            terrain.push({ top: newTop, bottom: newBottom });
        }
        
        if ((distance % CONFIG.segmentWidth) < scrollSpeed * dt) {
            terrain.shift();
        }

        // Birds
        if (Math.random() < (0.0025 + scrollSpeed * 0.000015) * dt * 60) {
            spawnBird();
        }
        
        birds.forEach(bird => {
            bird.x += bird.vx * dt;
            bird.flap += bird.flapSpeed;
            
            // Collision
            if (Math.abs(helicopter.x - bird.x) < 22 && Math.abs(helicopter.y - bird.y) < 18) {
                gameOver(true);
            }
        });
        birds = birds.filter(b => b.x > -50);

        // Terrain collision
        const heliIndex = Math.floor(helicopter.x / CONFIG.segmentWidth);
        if (terrain[heliIndex]) {
            const ceiling = terrain[heliIndex].top;
            const floor = height - terrain[heliIndex].bottom;
            
            if (helicopter.y - helicopter.radius < ceiling || helicopter.y + helicopter.radius > floor) {
                gameOver(false);
            }
        }
        
        if (helicopter.y < 0 || helicopter.y > height) {
            gameOver(false);
        }

        // Update particles
        particles.forEach(p => {
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.life -= 1.8 * dt;
        });
        particles = particles.filter(p => p.life > 0);

        // Update shake
        if (shake.intensity > 0) {
            shake.x = (Math.random() - 0.5) * shake.intensity;
            shake.y = (Math.random() - 0.5) * shake.intensity;
            shake.intensity *= 0.92;
        }

        // Update HUD
        elAlt.innerText = String(Math.floor(height - helicopter.y)).padStart(4, '0');
        elDist.innerText = String(Math.floor(distance / 10)).padStart(4, '0');
    }

    function gameOver(isBird) {
        state = 'CRASHED';
        shake.intensity = 22;
        inputActive = false;
        pointerDown = false;
        keysPressed.up = false;
        keysPressed.down = false;
        touchZone.classList.remove('active');

        // CRITICAL: Stop sound immediately on crash
        Audio.fadeOut();
        Audio.playExplosion();
        if (isBird) Audio.playBirdHit();

        elSys.innerText = isBird ? "BIRD STRIKE" : "IMPACT";
        elSys.style.color = "var(--alert)";

        setTimeout(() => {
            // Ensure sound is completely stopped
            Audio.stop();
            
            title.innerText = "MISSION FAILED";
            title.style.color = "var(--alert)";
            desc.innerHTML = `DISTANCE: ${Math.floor(distance / 10)}<br>CAUSE: ${isBird ? "BIRD STRIKE" : "TERRAIN IMPACT"}<br><br>TAP OR PRESS ENTER TO RESTART`;
            btnStart.innerText = "REBOOT SYSTEM";
            menu.classList.remove('hidden');
            
            canRestart = false;
            setTimeout(() => { canRestart = true; }, 400);
            
            state = 'MENU';
            initDust();
        }, 550);
    }

    // ===== RENDERING =====
    function draw() {
        // Clear
        ctx.fillStyle = '#050505';
        ctx.fillRect(0, 0, width, height);

        if (state === 'MENU' || state === 'PAUSED') {
            drawStars();
            drawDust();
            
            if (state === 'PAUSED') {
                ctx.globalAlpha = 0.25;
                drawGameWorld();
                ctx.globalAlpha = 1;
            }
            return;
        }

        drawGameWorld();
    }

    function drawGameWorld() {
        ctx.save();
        ctx.translate(shake.x, shake.y);

        // Stars (background)
        drawStars();

        // Terrain with 3D depth effect
        const offset = -(distance % CONFIG.segmentWidth);
        
        // Draw terrain glow/shadow first
        ctx.strokeStyle = 'rgba(57, 255, 20, 0.3)';
        ctx.lineWidth = 5;
        ctx.shadowBlur = 12;
        ctx.shadowColor = '#39ff14';
        
        // Top terrain
        ctx.beginPath();
        ctx.moveTo(offset, terrain[0]?.top || 0);
        terrain.forEach((t, i) => {
            ctx.lineTo(offset + i * CONFIG.segmentWidth, t.top);
        });
        ctx.stroke();

        // Bottom terrain
        ctx.beginPath();
        ctx.moveTo(offset, height - (terrain[0]?.bottom || 0));
        terrain.forEach((t, i) => {
            ctx.lineTo(offset + i * CONFIG.segmentWidth, height - t.bottom);
        });
        ctx.stroke();

        // Main terrain lines
        ctx.strokeStyle = '#39ff14';
        ctx.lineWidth = 2;
        ctx.shadowBlur = 6;

        ctx.beginPath();
        ctx.moveTo(offset, terrain[0]?.top || 0);
        terrain.forEach((t, i) => {
            ctx.lineTo(offset + i * CONFIG.segmentWidth, t.top);
        });
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(offset, height - (terrain[0]?.bottom || 0));
        terrain.forEach((t, i) => {
            ctx.lineTo(offset + i * CONFIG.segmentWidth, height - t.bottom);
        });
        ctx.stroke();

        // Birds
        ctx.strokeStyle = '#ffaa55';
        ctx.lineWidth = 2;
        ctx.shadowColor = '#ff8844';
        ctx.shadowBlur = 6;
        birds.forEach(b => {
            const wingY = Math.sin(b.flap) * 9;
            ctx.beginPath();
            ctx.moveTo(b.x, b.y);
            ctx.lineTo(b.x + 9, b.y + wingY);
            ctx.lineTo(b.x + 18, b.y);
            ctx.stroke();
        });

        // Particles
        ctx.shadowBlur = 4;
        ctx.shadowColor = '#39ff14';
        particles.forEach(p => {
            ctx.fillStyle = `rgba(57, 255, 20, ${p.life})`;
            ctx.fillRect(p.x, p.y, 3, 3);
        });

        // Draw helicopter (3D-style)
        ctx.save();
        ctx.translate(helicopter.x, helicopter.y);
        ctx.rotate(helicopter.angle);
        
        ctx.strokeStyle = '#39ff14';
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#39ff14';
        ctx.lineWidth = 2;
        
        // Body (3D oval)
        ctx.beginPath();
        ctx.ellipse(0, 0, helicopter.radius + 4, helicopter.radius, 0, 0, Math.PI * 2);
        ctx.stroke();
        
        // Inner cockpit
        ctx.beginPath();
        ctx.ellipse(4, 0, 8, 6, 0, 0, Math.PI * 2);
        ctx.stroke();
        
        // Tail boom
        ctx.beginPath();
        ctx.moveTo(-10, 0);
        ctx.lineTo(-32, 0);
        ctx.moveTo(-32, -5);
        ctx.lineTo(-32, 5);
        ctx.stroke();

        // Rotor (animated, 3D perspective)
        const rotorSpan = 38 * Math.cos(helicopter.rotorAngle);
        ctx.beginPath();
        ctx.moveTo(-rotorSpan, -13);
        ctx.lineTo(rotorSpan, -13);
        ctx.moveTo(0, -13);
        ctx.lineTo(0, -10);
        ctx.stroke();

        // Skids (3D depth)
        ctx.strokeStyle = 'rgba(57, 255, 20, 0.7)';
        ctx.beginPath();
        ctx.moveTo(-12, 12);
        ctx.lineTo(10, 12);
        ctx.moveTo(-12, 14);
        ctx.lineTo(10, 14);
        ctx.stroke();

        // Thrust flame
        if (inputActive) {
            ctx.fillStyle = '#fff';
            ctx.shadowColor = '#fff';
            ctx.beginPath();
            ctx.moveTo(-3, 8);
            ctx.lineTo(3, 8);
            ctx.lineTo(0, 18 + Math.random() * 8);
            ctx.fill();
        }

        ctx.restore();
        ctx.restore();
    }

    // ===== MAIN LOOP (60 FPS) =====
    function gameLoop(currentTime) {
        // FPS calculation
        frameCount++;
        if (currentTime - lastFpsUpdate >= 1000) {
            currentFps = frameCount;
            elFps.innerText = currentFps;
            frameCount = 0;
            lastFpsUpdate = currentTime;
        }

        // Delta time
        if (!lastFrameTime) lastFrameTime = currentTime;
        const deltaTime = (currentTime - lastFrameTime) / 1000;
        lastFrameTime = currentTime;

        // Update
        if (state === 'PLAYING') {
            update(deltaTime);
        } else if (state === 'MENU' || state === 'PAUSED') {
            updateDust(deltaTime);
            updateStars(deltaTime * 0.3);
        }

        // Render
        draw();

        requestAnimationFrame(gameLoop);
    }

    // ===== INITIALIZATION =====
    function init() {
        resize();
        initDust();
        initStars();
        
        btnStart.addEventListener('click', () => {
            if (state === 'PAUSED') resumeGame();
            else resetGame();
        });

        requestAnimationFrame(gameLoop);
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
})();
</script>
</body>
</html>
